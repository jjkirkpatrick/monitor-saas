// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: monitor_results.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createMonitorResult = `-- name: CreateMonitorResult :one
INSERT INTO monitor_results (
    monitor_id,
    location,
    success,
    latency,
    status_code,
    response_size,
    error_message,
    certificate_expiry,
    dns_resolution_time,
    tls_handshake_time,
    connect_time,
    first_byte_time,
    total_time
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, monitor_id, time, location, success, latency, status_code, response_size, error_message, certificate_expiry, dns_resolution_time, tls_handshake_time, connect_time, first_byte_time, total_time
`

type CreateMonitorResultParams struct {
	MonitorID         uuid.UUID
	Location          string
	Success           bool
	Latency           pgtype.Int4
	StatusCode        pgtype.Int4
	ResponseSize      pgtype.Int4
	ErrorMessage      pgtype.Text
	CertificateExpiry pgtype.Timestamptz
	DnsResolutionTime pgtype.Int4
	TlsHandshakeTime  pgtype.Int4
	ConnectTime       pgtype.Int4
	FirstByteTime     pgtype.Int4
	TotalTime         pgtype.Int4
}

func (q *Queries) CreateMonitorResult(ctx context.Context, arg CreateMonitorResultParams) (MonitorResult, error) {
	row := q.db.QueryRow(ctx, createMonitorResult,
		arg.MonitorID,
		arg.Location,
		arg.Success,
		arg.Latency,
		arg.StatusCode,
		arg.ResponseSize,
		arg.ErrorMessage,
		arg.CertificateExpiry,
		arg.DnsResolutionTime,
		arg.TlsHandshakeTime,
		arg.ConnectTime,
		arg.FirstByteTime,
		arg.TotalTime,
	)
	var i MonitorResult
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Time,
		&i.Location,
		&i.Success,
		&i.Latency,
		&i.StatusCode,
		&i.ResponseSize,
		&i.ErrorMessage,
		&i.CertificateExpiry,
		&i.DnsResolutionTime,
		&i.TlsHandshakeTime,
		&i.ConnectTime,
		&i.FirstByteTime,
		&i.TotalTime,
	)
	return i, err
}

const deleteOldMonitorResults = `-- name: DeleteOldMonitorResults :exec
DELETE FROM monitor_results
WHERE time < NOW() - ($1 || ' days')::interval
`

func (q *Queries) DeleteOldMonitorResults(ctx context.Context, dollar_1 pgtype.Text) error {
	_, err := q.db.Exec(ctx, deleteOldMonitorResults, dollar_1)
	return err
}

const getFailedChecks = `-- name: GetFailedChecks :many
SELECT id, monitor_id, time, location, success, latency, status_code, response_size, error_message, certificate_expiry, dns_resolution_time, tls_handshake_time, connect_time, first_byte_time, total_time FROM monitor_results
WHERE monitor_id = $1
AND success = false
AND time >= $2
AND time <= $3
ORDER BY time DESC
LIMIT $4
`

type GetFailedChecksParams struct {
	MonitorID uuid.UUID
	Time      pgtype.Timestamptz
	Time_2    pgtype.Timestamptz
	Limit     int32
}

func (q *Queries) GetFailedChecks(ctx context.Context, arg GetFailedChecksParams) ([]MonitorResult, error) {
	rows, err := q.db.Query(ctx, getFailedChecks,
		arg.MonitorID,
		arg.Time,
		arg.Time_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonitorResult
	for rows.Next() {
		var i MonitorResult
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.Time,
			&i.Location,
			&i.Success,
			&i.Latency,
			&i.StatusCode,
			&i.ResponseSize,
			&i.ErrorMessage,
			&i.CertificateExpiry,
			&i.DnsResolutionTime,
			&i.TlsHandshakeTime,
			&i.ConnectTime,
			&i.FirstByteTime,
			&i.TotalTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMonitorResult = `-- name: GetLatestMonitorResult :one
SELECT id, monitor_id, time, location, success, latency, status_code, response_size, error_message, certificate_expiry, dns_resolution_time, tls_handshake_time, connect_time, first_byte_time, total_time FROM monitor_results
WHERE monitor_id = $1
ORDER BY time DESC
LIMIT 1
`

func (q *Queries) GetLatestMonitorResult(ctx context.Context, monitorID uuid.UUID) (MonitorResult, error) {
	row := q.db.QueryRow(ctx, getLatestMonitorResult, monitorID)
	var i MonitorResult
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Time,
		&i.Location,
		&i.Success,
		&i.Latency,
		&i.StatusCode,
		&i.ResponseSize,
		&i.ErrorMessage,
		&i.CertificateExpiry,
		&i.DnsResolutionTime,
		&i.TlsHandshakeTime,
		&i.ConnectTime,
		&i.FirstByteTime,
		&i.TotalTime,
	)
	return i, err
}

const getMonitorHourlyStats = `-- name: GetMonitorHourlyStats :many
SELECT
    bucket,
    monitor_id,
    location,
    total_checks,
    successful_checks,
    avg_latency,
    min_latency,
    max_latency,
    most_common_status,
    ROUND((successful_checks::float / total_checks::float * 100)::numeric, 2) as success_rate
FROM monitor_results_hourly
WHERE monitor_id = $1
AND bucket >= $2
AND bucket <= $3
ORDER BY bucket DESC
`

type GetMonitorHourlyStatsParams struct {
	MonitorID uuid.UUID
	Bucket    pgtype.Interval
	Bucket_2  pgtype.Interval
}

type GetMonitorHourlyStatsRow struct {
	Bucket           pgtype.Interval
	MonitorID        uuid.UUID
	Location         string
	TotalChecks      int64
	SuccessfulChecks int64
	AvgLatency       float64
	MinLatency       interface{}
	MaxLatency       interface{}
	MostCommonStatus interface{}
	SuccessRate      pgtype.Numeric
}

func (q *Queries) GetMonitorHourlyStats(ctx context.Context, arg GetMonitorHourlyStatsParams) ([]GetMonitorHourlyStatsRow, error) {
	rows, err := q.db.Query(ctx, getMonitorHourlyStats, arg.MonitorID, arg.Bucket, arg.Bucket_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonitorHourlyStatsRow
	for rows.Next() {
		var i GetMonitorHourlyStatsRow
		if err := rows.Scan(
			&i.Bucket,
			&i.MonitorID,
			&i.Location,
			&i.TotalChecks,
			&i.SuccessfulChecks,
			&i.AvgLatency,
			&i.MinLatency,
			&i.MaxLatency,
			&i.MostCommonStatus,
			&i.SuccessRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitorResults = `-- name: GetMonitorResults :many
SELECT id, monitor_id, time, location, success, latency, status_code, response_size, error_message, certificate_expiry, dns_resolution_time, tls_handshake_time, connect_time, first_byte_time, total_time FROM monitor_results
WHERE monitor_id = $1
AND time >= $2
AND time <= $3
ORDER BY time DESC
LIMIT $4
`

type GetMonitorResultsParams struct {
	MonitorID uuid.UUID
	Time      pgtype.Timestamptz
	Time_2    pgtype.Timestamptz
	Limit     int32
}

func (q *Queries) GetMonitorResults(ctx context.Context, arg GetMonitorResultsParams) ([]MonitorResult, error) {
	rows, err := q.db.Query(ctx, getMonitorResults,
		arg.MonitorID,
		arg.Time,
		arg.Time_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonitorResult
	for rows.Next() {
		var i MonitorResult
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.Time,
			&i.Location,
			&i.Success,
			&i.Latency,
			&i.StatusCode,
			&i.ResponseSize,
			&i.ErrorMessage,
			&i.CertificateExpiry,
			&i.DnsResolutionTime,
			&i.TlsHandshakeTime,
			&i.ConnectTime,
			&i.FirstByteTime,
			&i.TotalTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitorResultsByLocation = `-- name: GetMonitorResultsByLocation :many
SELECT id, monitor_id, time, location, success, latency, status_code, response_size, error_message, certificate_expiry, dns_resolution_time, tls_handshake_time, connect_time, first_byte_time, total_time FROM monitor_results
WHERE monitor_id = $1
AND location = $2
AND time >= $3
AND time <= $4
ORDER BY time DESC
LIMIT $5
`

type GetMonitorResultsByLocationParams struct {
	MonitorID uuid.UUID
	Location  string
	Time      pgtype.Timestamptz
	Time_2    pgtype.Timestamptz
	Limit     int32
}

func (q *Queries) GetMonitorResultsByLocation(ctx context.Context, arg GetMonitorResultsByLocationParams) ([]MonitorResult, error) {
	rows, err := q.db.Query(ctx, getMonitorResultsByLocation,
		arg.MonitorID,
		arg.Location,
		arg.Time,
		arg.Time_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonitorResult
	for rows.Next() {
		var i MonitorResult
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.Time,
			&i.Location,
			&i.Success,
			&i.Latency,
			&i.StatusCode,
			&i.ResponseSize,
			&i.ErrorMessage,
			&i.CertificateExpiry,
			&i.DnsResolutionTime,
			&i.TlsHandshakeTime,
			&i.ConnectTime,
			&i.FirstByteTime,
			&i.TotalTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitorResultsCount = `-- name: GetMonitorResultsCount :one
SELECT COUNT(*) FROM monitor_results
WHERE monitor_id = $1
AND time >= $2
AND time <= $3
`

type GetMonitorResultsCountParams struct {
	MonitorID uuid.UUID
	Time      pgtype.Timestamptz
	Time_2    pgtype.Timestamptz
}

func (q *Queries) GetMonitorResultsCount(ctx context.Context, arg GetMonitorResultsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getMonitorResultsCount, arg.MonitorID, arg.Time, arg.Time_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMonitorStats = `-- name: GetMonitorStats :one
SELECT
    COUNT(*) as total_checks,
    COUNT(*) FILTER (WHERE success = true) as successful_checks,
    ROUND(AVG(latency)::numeric, 2) as avg_latency,
    MAX(latency) as max_latency,
    MIN(latency) as min_latency,
    ROUND((COUNT(*) FILTER (WHERE success = true)::float / COUNT(*)::float * 100)::numeric, 2) as success_rate,
    MODE() WITHIN GROUP (ORDER BY status_code) as most_common_status_code,
    MAX(certificate_expiry) as latest_cert_expiry,
    ROUND(AVG(dns_resolution_time)::numeric, 2) as avg_dns_time,
    ROUND(AVG(tls_handshake_time)::numeric, 2) as avg_tls_time,
    ROUND(AVG(connect_time)::numeric, 2) as avg_connect_time,
    ROUND(AVG(first_byte_time)::numeric, 2) as avg_ttfb
FROM monitor_results
WHERE monitor_id = $1
AND time >= $2
AND time <= $3
`

type GetMonitorStatsParams struct {
	MonitorID uuid.UUID
	Time      pgtype.Timestamptz
	Time_2    pgtype.Timestamptz
}

type GetMonitorStatsRow struct {
	TotalChecks          int64
	SuccessfulChecks     int64
	AvgLatency           pgtype.Numeric
	MaxLatency           interface{}
	MinLatency           interface{}
	SuccessRate          pgtype.Numeric
	MostCommonStatusCode interface{}
	LatestCertExpiry     interface{}
	AvgDnsTime           pgtype.Numeric
	AvgTlsTime           pgtype.Numeric
	AvgConnectTime       pgtype.Numeric
	AvgTtfb              pgtype.Numeric
}

func (q *Queries) GetMonitorStats(ctx context.Context, arg GetMonitorStatsParams) (GetMonitorStatsRow, error) {
	row := q.db.QueryRow(ctx, getMonitorStats, arg.MonitorID, arg.Time, arg.Time_2)
	var i GetMonitorStatsRow
	err := row.Scan(
		&i.TotalChecks,
		&i.SuccessfulChecks,
		&i.AvgLatency,
		&i.MaxLatency,
		&i.MinLatency,
		&i.SuccessRate,
		&i.MostCommonStatusCode,
		&i.LatestCertExpiry,
		&i.AvgDnsTime,
		&i.AvgTlsTime,
		&i.AvgConnectTime,
		&i.AvgTtfb,
	)
	return i, err
}

const getMonitorStatsGroupedByLocation = `-- name: GetMonitorStatsGroupedByLocation :many
SELECT
    location,
    COUNT(*) as total_checks,
    COUNT(*) FILTER (WHERE success = true) as successful_checks,
    ROUND(AVG(latency)::numeric, 2) as avg_latency,
    MAX(latency) as max_latency,
    MIN(latency) as min_latency,
    ROUND((COUNT(*) FILTER (WHERE success = true)::float / COUNT(*)::float * 100)::numeric, 2) as success_rate
FROM monitor_results
WHERE monitor_id = $1
AND time >= $2
AND time <= $3
GROUP BY location
ORDER BY location
`

type GetMonitorStatsGroupedByLocationParams struct {
	MonitorID uuid.UUID
	Time      pgtype.Timestamptz
	Time_2    pgtype.Timestamptz
}

type GetMonitorStatsGroupedByLocationRow struct {
	Location         string
	TotalChecks      int64
	SuccessfulChecks int64
	AvgLatency       pgtype.Numeric
	MaxLatency       interface{}
	MinLatency       interface{}
	SuccessRate      pgtype.Numeric
}

func (q *Queries) GetMonitorStatsGroupedByLocation(ctx context.Context, arg GetMonitorStatsGroupedByLocationParams) ([]GetMonitorStatsGroupedByLocationRow, error) {
	rows, err := q.db.Query(ctx, getMonitorStatsGroupedByLocation, arg.MonitorID, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonitorStatsGroupedByLocationRow
	for rows.Next() {
		var i GetMonitorStatsGroupedByLocationRow
		if err := rows.Scan(
			&i.Location,
			&i.TotalChecks,
			&i.SuccessfulChecks,
			&i.AvgLatency,
			&i.MaxLatency,
			&i.MinLatency,
			&i.SuccessRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitorTimeSeries = `-- name: GetMonitorTimeSeries :many
WITH time_buckets AS (
    SELECT
        date_trunc($4::text, time) as bucket,
        COUNT(*) as total_checks,
        COUNT(*) FILTER (WHERE success = true) as successful_checks,
        ROUND(AVG(latency)::numeric, 2) as avg_latency,
        MAX(latency) as max_latency,
        MIN(latency) as min_latency
    FROM monitor_results
    WHERE monitor_id = $1
    AND time >= $2
    AND time <= $3
    GROUP BY bucket
    ORDER BY bucket
)
SELECT
    bucket as time,
    total_checks,
    successful_checks,
    avg_latency,
    max_latency,
    min_latency,
    ROUND((successful_checks::float / total_checks::float * 100)::numeric, 2) as success_rate
FROM time_buckets
`

type GetMonitorTimeSeriesParams struct {
	MonitorID uuid.UUID
	Time      pgtype.Timestamptz
	Time_2    pgtype.Timestamptz
	Column4   string
}

type GetMonitorTimeSeriesRow struct {
	Time             pgtype.Interval
	TotalChecks      int64
	SuccessfulChecks int64
	AvgLatency       pgtype.Numeric
	MaxLatency       interface{}
	MinLatency       interface{}
	SuccessRate      pgtype.Numeric
}

func (q *Queries) GetMonitorTimeSeries(ctx context.Context, arg GetMonitorTimeSeriesParams) ([]GetMonitorTimeSeriesRow, error) {
	rows, err := q.db.Query(ctx, getMonitorTimeSeries,
		arg.MonitorID,
		arg.Time,
		arg.Time_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonitorTimeSeriesRow
	for rows.Next() {
		var i GetMonitorTimeSeriesRow
		if err := rows.Scan(
			&i.Time,
			&i.TotalChecks,
			&i.SuccessfulChecks,
			&i.AvgLatency,
			&i.MaxLatency,
			&i.MinLatency,
			&i.SuccessRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshHourlyStats = `-- name: RefreshHourlyStats :exec
SELECT refresh_monitor_results_hourly()
`

func (q *Queries) RefreshHourlyStats(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshHourlyStats)
	return err
}
