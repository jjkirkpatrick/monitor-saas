// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const generateApiKey = `-- name: GenerateApiKey :one
WITH new_key AS (
    SELECT generate_api_key() as key
)
UPDATE user_settings
SET
    api_key = new_key.key,
    api_key_enabled = true,
    api_key_created_at = NOW()
FROM new_key
WHERE user_id = $1
RETURNING api_key
`

func (q *Queries) GenerateApiKey(ctx context.Context, userID uuid.UUID) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, generateApiKey, userID)
	var api_key pgtype.Text
	err := row.Scan(&api_key)
	return api_key, err
}

const getUserLimits = `-- name: GetUserLimits :one
SELECT user_id, max_monitors, max_checks_per_day, max_alert_configs_per_monitor, max_notification_channels, retention_days, api_rate_limit_per_minute, created_at, updated_at FROM user_limits
WHERE user_id = $1
`

func (q *Queries) GetUserLimits(ctx context.Context, userID uuid.UUID) (UserLimit, error) {
	row := q.db.QueryRow(ctx, getUserLimits, userID)
	var i UserLimit
	err := row.Scan(
		&i.UserID,
		&i.MaxMonitors,
		&i.MaxChecksPerDay,
		&i.MaxAlertConfigsPerMonitor,
		&i.MaxNotificationChannels,
		&i.RetentionDays,
		&i.ApiRateLimitPerMinute,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserMonitoringStats = `-- name: GetUserMonitoringStats :one
SELECT
    COUNT(*) total_monitors,
    COUNT(*) FILTER (WHERE status = 'active') active_monitors,
    COUNT(*) FILTER (WHERE status = 'paused') paused_monitors,
    COUNT(*) FILTER (WHERE status = 'error') error_monitors,
    (
        SELECT COUNT(*) 
        FROM monitor_results mr
        JOIN monitors m2 ON mr.monitor_id = m2.id
        WHERE m2.user_id = $1
        AND mr.time > NOW() - INTERVAL '24 hours'
    ) checks_24h,
    (
        SELECT COUNT(*) 
        FROM monitor_results mr
        JOIN monitors m2 ON mr.monitor_id = m2.id
        WHERE m2.user_id = $1
        AND mr.time > NOW() - INTERVAL '24 hours'
        AND mr.success = true
    ) successful_checks_24h,
    (
        SELECT ROUND(AVG(latency)::numeric, 2)
        FROM monitor_results mr
        JOIN monitors m2 ON mr.monitor_id = m2.id
        WHERE m2.user_id = $1
        AND mr.time > NOW() - INTERVAL '24 hours'
    ) avg_latency_24h,
    (
        SELECT COUNT(*)
        FROM alert_history ah
        JOIN monitors m2 ON ah.monitor_id = m2.id
        WHERE m2.user_id = $1
        AND ah.triggered_at > NOW() - INTERVAL '24 hours'
    ) alerts_24h,
    (
        SELECT COUNT(*)
        FROM alert_history ah
        JOIN monitors m2 ON ah.monitor_id = m2.id
        WHERE m2.user_id = $1
        AND ah.triggered_at > NOW() - INTERVAL '24 hours'
        AND ah.status = 'triggered'
    ) active_alerts_24h
FROM monitors m
WHERE m.user_id = $1
`

type GetUserMonitoringStatsRow struct {
	TotalMonitors       int64
	ActiveMonitors      int64
	PausedMonitors      int64
	ErrorMonitors       int64
	Checks24h           int64
	SuccessfulChecks24h int64
	AvgLatency24h       pgtype.Numeric
	Alerts24h           int64
	ActiveAlerts24h     int64
}

func (q *Queries) GetUserMonitoringStats(ctx context.Context, userID uuid.UUID) (GetUserMonitoringStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserMonitoringStats, userID)
	var i GetUserMonitoringStatsRow
	err := row.Scan(
		&i.TotalMonitors,
		&i.ActiveMonitors,
		&i.PausedMonitors,
		&i.ErrorMonitors,
		&i.Checks24h,
		&i.SuccessfulChecks24h,
		&i.AvgLatency24h,
		&i.Alerts24h,
		&i.ActiveAlerts24h,
	)
	return i, err
}

const getUserSettings = `-- name: GetUserSettings :one
SELECT user_id, theme, timezone, date_format, time_format, default_dashboard_view, dashboard_refresh_interval, email_digest_enabled, email_digest_frequency, mobile_number, telegram_username, webhook_secret, api_key_enabled, api_key, api_key_created_at, api_key_last_used_at, created_at, updated_at FROM user_settings
WHERE user_id = $1
`

func (q *Queries) GetUserSettings(ctx context.Context, userID uuid.UUID) (UserSetting, error) {
	row := q.db.QueryRow(ctx, getUserSettings, userID)
	var i UserSetting
	err := row.Scan(
		&i.UserID,
		&i.Theme,
		&i.Timezone,
		&i.DateFormat,
		&i.TimeFormat,
		&i.DefaultDashboardView,
		&i.DashboardRefreshInterval,
		&i.EmailDigestEnabled,
		&i.EmailDigestFrequency,
		&i.MobileNumber,
		&i.TelegramUsername,
		&i.WebhookSecret,
		&i.ApiKeyEnabled,
		&i.ApiKey,
		&i.ApiKeyCreatedAt,
		&i.ApiKeyLastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserUsageStats = `-- name: GetUserUsageStats :one
SELECT user_id, date, total_checks, total_alerts_triggered, total_notifications_sent, api_calls, data_transfer_bytes FROM user_usage_stats
WHERE user_id = $1 AND date = $2
`

type GetUserUsageStatsParams struct {
	UserID uuid.UUID
	Date   pgtype.Date
}

func (q *Queries) GetUserUsageStats(ctx context.Context, arg GetUserUsageStatsParams) (UserUsageStat, error) {
	row := q.db.QueryRow(ctx, getUserUsageStats, arg.UserID, arg.Date)
	var i UserUsageStat
	err := row.Scan(
		&i.UserID,
		&i.Date,
		&i.TotalChecks,
		&i.TotalAlertsTriggered,
		&i.TotalNotificationsSent,
		&i.ApiCalls,
		&i.DataTransferBytes,
	)
	return i, err
}

const getUserUsageStatsByDateRange = `-- name: GetUserUsageStatsByDateRange :many
SELECT
    date,
    total_checks,
    total_alerts_triggered,
    total_notifications_sent,
    api_calls,
    data_transfer_bytes
FROM user_usage_stats
WHERE user_id = $1
AND date >= $2
AND date <= $3
ORDER BY date
`

type GetUserUsageStatsByDateRangeParams struct {
	UserID uuid.UUID
	Date   pgtype.Date
	Date_2 pgtype.Date
}

type GetUserUsageStatsByDateRangeRow struct {
	Date                   pgtype.Date
	TotalChecks            int32
	TotalAlertsTriggered   int32
	TotalNotificationsSent int32
	ApiCalls               int32
	DataTransferBytes      int64
}

func (q *Queries) GetUserUsageStatsByDateRange(ctx context.Context, arg GetUserUsageStatsByDateRangeParams) ([]GetUserUsageStatsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getUserUsageStatsByDateRange, arg.UserID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserUsageStatsByDateRangeRow
	for rows.Next() {
		var i GetUserUsageStatsByDateRangeRow
		if err := rows.Scan(
			&i.Date,
			&i.TotalChecks,
			&i.TotalAlertsTriggered,
			&i.TotalNotificationsSent,
			&i.ApiCalls,
			&i.DataTransferBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersNearingLimits = `-- name: GetUsersNearingLimits :many
WITH user_monitor_counts AS (
    SELECT
        m.user_id,
        COUNT(*) as monitor_count
    FROM monitors m
    GROUP BY m.user_id
),
user_check_counts AS (
    SELECT
        m.user_id,
        COUNT(*) as check_count
    FROM monitor_results mr
    JOIN monitors m ON mr.monitor_id = m.id
    WHERE mr.time >= CURRENT_DATE
    GROUP BY m.user_id
),
user_alert_counts AS (
    SELECT
        m.user_id,
        COUNT(*) as alert_count
    FROM alert_configs ac
    JOIN monitors m ON ac.monitor_id = m.id
    GROUP BY m.user_id
)
SELECT
    ul.user_id, ul.max_monitors, ul.max_checks_per_day, ul.max_alert_configs_per_monitor, ul.max_notification_channels, ul.retention_days, ul.api_rate_limit_per_minute, ul.created_at, ul.updated_at,
    COALESCE(umc.monitor_count, 0) as current_monitor_count,
    COALESCE(ucc.check_count, 0) as current_check_count,
    COALESCE(uac.alert_count, 0) as current_alert_count
FROM user_limits ul
LEFT JOIN user_monitor_counts umc ON ul.user_id = umc.user_id
LEFT JOIN user_check_counts ucc ON ul.user_id = ucc.user_id
LEFT JOIN user_alert_counts uac ON ul.user_id = uac.user_id
WHERE
    COALESCE(umc.monitor_count, 0) >= ul.max_monitors * 0.8
    OR COALESCE(ucc.check_count, 0) >= ul.max_checks_per_day * 0.8
`

type GetUsersNearingLimitsRow struct {
	UserID                    uuid.UUID
	MaxMonitors               int32
	MaxChecksPerDay           int32
	MaxAlertConfigsPerMonitor int32
	MaxNotificationChannels   int32
	RetentionDays             int32
	ApiRateLimitPerMinute     int32
	CreatedAt                 pgtype.Timestamptz
	UpdatedAt                 pgtype.Timestamptz
	CurrentMonitorCount       int64
	CurrentCheckCount         int64
	CurrentAlertCount         int64
}

func (q *Queries) GetUsersNearingLimits(ctx context.Context) ([]GetUsersNearingLimitsRow, error) {
	rows, err := q.db.Query(ctx, getUsersNearingLimits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersNearingLimitsRow
	for rows.Next() {
		var i GetUsersNearingLimitsRow
		if err := rows.Scan(
			&i.UserID,
			&i.MaxMonitors,
			&i.MaxChecksPerDay,
			&i.MaxAlertConfigsPerMonitor,
			&i.MaxNotificationChannels,
			&i.RetentionDays,
			&i.ApiRateLimitPerMinute,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentMonitorCount,
			&i.CurrentCheckCount,
			&i.CurrentAlertCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetUserSettings = `-- name: ResetUserSettings :one
UPDATE user_settings
SET
    theme = 'system',
    timezone = 'UTC',
    date_format = 'YYYY-MM-DD',
    time_format = 'HH:mm:ss',
    default_dashboard_view = 'overview',
    dashboard_refresh_interval = 60,
    email_digest_enabled = true,
    email_digest_frequency = 'daily',
    mobile_number = NULL,
    telegram_username = NULL,
    webhook_secret = NULL,
    api_key_enabled = false,
    api_key = NULL,
    api_key_created_at = NULL,
    api_key_last_used_at = NULL
WHERE user_id = $1
RETURNING user_id, theme, timezone, date_format, time_format, default_dashboard_view, dashboard_refresh_interval, email_digest_enabled, email_digest_frequency, mobile_number, telegram_username, webhook_secret, api_key_enabled, api_key, api_key_created_at, api_key_last_used_at, created_at, updated_at
`

func (q *Queries) ResetUserSettings(ctx context.Context, userID uuid.UUID) (UserSetting, error) {
	row := q.db.QueryRow(ctx, resetUserSettings, userID)
	var i UserSetting
	err := row.Scan(
		&i.UserID,
		&i.Theme,
		&i.Timezone,
		&i.DateFormat,
		&i.TimeFormat,
		&i.DefaultDashboardView,
		&i.DashboardRefreshInterval,
		&i.EmailDigestEnabled,
		&i.EmailDigestFrequency,
		&i.MobileNumber,
		&i.TelegramUsername,
		&i.WebhookSecret,
		&i.ApiKeyEnabled,
		&i.ApiKey,
		&i.ApiKeyCreatedAt,
		&i.ApiKeyLastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const revokeApiKey = `-- name: RevokeApiKey :exec
UPDATE user_settings
SET
    api_key = NULL,
    api_key_enabled = false,
    api_key_created_at = NULL,
    api_key_last_used_at = NULL
WHERE user_id = $1
`

func (q *Queries) RevokeApiKey(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeApiKey, userID)
	return err
}

const toggleSetting = `-- name: ToggleSetting :one
UPDATE user_settings
SET
    email_digest_enabled = CASE WHEN $2 = 'email_digest_enabled' THEN NOT email_digest_enabled ELSE email_digest_enabled END,
    api_key_enabled = CASE WHEN $2 = 'api_key_enabled' THEN NOT api_key_enabled ELSE api_key_enabled END
WHERE user_id = $1
RETURNING user_id, theme, timezone, date_format, time_format, default_dashboard_view, dashboard_refresh_interval, email_digest_enabled, email_digest_frequency, mobile_number, telegram_username, webhook_secret, api_key_enabled, api_key, api_key_created_at, api_key_last_used_at, created_at, updated_at
`

type ToggleSettingParams struct {
	UserID  uuid.UUID
	Column2 interface{}
}

func (q *Queries) ToggleSetting(ctx context.Context, arg ToggleSettingParams) (UserSetting, error) {
	row := q.db.QueryRow(ctx, toggleSetting, arg.UserID, arg.Column2)
	var i UserSetting
	err := row.Scan(
		&i.UserID,
		&i.Theme,
		&i.Timezone,
		&i.DateFormat,
		&i.TimeFormat,
		&i.DefaultDashboardView,
		&i.DashboardRefreshInterval,
		&i.EmailDigestEnabled,
		&i.EmailDigestFrequency,
		&i.MobileNumber,
		&i.TelegramUsername,
		&i.WebhookSecret,
		&i.ApiKeyEnabled,
		&i.ApiKey,
		&i.ApiKeyCreatedAt,
		&i.ApiKeyLastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateApiKeyLastUsed = `-- name: UpdateApiKeyLastUsed :exec
UPDATE user_settings
SET api_key_last_used_at = NOW()
WHERE user_id = $1
`

func (q *Queries) UpdateApiKeyLastUsed(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateApiKeyLastUsed, userID)
	return err
}

const updateUserLimits = `-- name: UpdateUserLimits :one
UPDATE user_limits
SET
    max_monitors = COALESCE($2, max_monitors),
    max_checks_per_day = COALESCE($3, max_checks_per_day),
    max_alert_configs_per_monitor = COALESCE($4, max_alert_configs_per_monitor),
    max_notification_channels = COALESCE($5, max_notification_channels),
    retention_days = COALESCE($6, retention_days),
    api_rate_limit_per_minute = COALESCE($7, api_rate_limit_per_minute)
WHERE user_id = $1
RETURNING user_id, max_monitors, max_checks_per_day, max_alert_configs_per_monitor, max_notification_channels, retention_days, api_rate_limit_per_minute, created_at, updated_at
`

type UpdateUserLimitsParams struct {
	UserID                    uuid.UUID
	MaxMonitors               int32
	MaxChecksPerDay           int32
	MaxAlertConfigsPerMonitor int32
	MaxNotificationChannels   int32
	RetentionDays             int32
	ApiRateLimitPerMinute     int32
}

func (q *Queries) UpdateUserLimits(ctx context.Context, arg UpdateUserLimitsParams) (UserLimit, error) {
	row := q.db.QueryRow(ctx, updateUserLimits,
		arg.UserID,
		arg.MaxMonitors,
		arg.MaxChecksPerDay,
		arg.MaxAlertConfigsPerMonitor,
		arg.MaxNotificationChannels,
		arg.RetentionDays,
		arg.ApiRateLimitPerMinute,
	)
	var i UserLimit
	err := row.Scan(
		&i.UserID,
		&i.MaxMonitors,
		&i.MaxChecksPerDay,
		&i.MaxAlertConfigsPerMonitor,
		&i.MaxNotificationChannels,
		&i.RetentionDays,
		&i.ApiRateLimitPerMinute,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserSettings = `-- name: UpdateUserSettings :one
UPDATE user_settings
SET
    theme = COALESCE($2, theme),
    timezone = COALESCE($3, timezone),
    date_format = COALESCE($4, date_format),
    time_format = COALESCE($5, time_format),
    default_dashboard_view = COALESCE($6, default_dashboard_view),
    dashboard_refresh_interval = COALESCE($7, dashboard_refresh_interval),
    email_digest_enabled = COALESCE($8, email_digest_enabled),
    email_digest_frequency = COALESCE($9, email_digest_frequency),
    mobile_number = COALESCE($10, mobile_number),
    telegram_username = COALESCE($11, telegram_username),
    webhook_secret = COALESCE($12, webhook_secret),
    api_key_enabled = COALESCE($13, api_key_enabled),
    api_key = COALESCE($14, api_key),
    api_key_created_at = COALESCE($15, api_key_created_at)
WHERE user_id = $1
RETURNING user_id, theme, timezone, date_format, time_format, default_dashboard_view, dashboard_refresh_interval, email_digest_enabled, email_digest_frequency, mobile_number, telegram_username, webhook_secret, api_key_enabled, api_key, api_key_created_at, api_key_last_used_at, created_at, updated_at
`

type UpdateUserSettingsParams struct {
	UserID                   uuid.UUID
	Theme                    ThemePreference
	Timezone                 TimezonePreference
	DateFormat               string
	TimeFormat               string
	DefaultDashboardView     string
	DashboardRefreshInterval int32
	EmailDigestEnabled       bool
	EmailDigestFrequency     string
	MobileNumber             pgtype.Text
	TelegramUsername         pgtype.Text
	WebhookSecret            pgtype.Text
	ApiKeyEnabled            bool
	ApiKey                   pgtype.Text
	ApiKeyCreatedAt          pgtype.Timestamptz
}

func (q *Queries) UpdateUserSettings(ctx context.Context, arg UpdateUserSettingsParams) (UserSetting, error) {
	row := q.db.QueryRow(ctx, updateUserSettings,
		arg.UserID,
		arg.Theme,
		arg.Timezone,
		arg.DateFormat,
		arg.TimeFormat,
		arg.DefaultDashboardView,
		arg.DashboardRefreshInterval,
		arg.EmailDigestEnabled,
		arg.EmailDigestFrequency,
		arg.MobileNumber,
		arg.TelegramUsername,
		arg.WebhookSecret,
		arg.ApiKeyEnabled,
		arg.ApiKey,
		arg.ApiKeyCreatedAt,
	)
	var i UserSetting
	err := row.Scan(
		&i.UserID,
		&i.Theme,
		&i.Timezone,
		&i.DateFormat,
		&i.TimeFormat,
		&i.DefaultDashboardView,
		&i.DashboardRefreshInterval,
		&i.EmailDigestEnabled,
		&i.EmailDigestFrequency,
		&i.MobileNumber,
		&i.TelegramUsername,
		&i.WebhookSecret,
		&i.ApiKeyEnabled,
		&i.ApiKey,
		&i.ApiKeyCreatedAt,
		&i.ApiKeyLastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserUsageStats = `-- name: UpsertUserUsageStats :one
INSERT INTO user_usage_stats (
    user_id,
    date,
    total_checks,
    total_alerts_triggered,
    total_notifications_sent,
    api_calls,
    data_transfer_bytes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (user_id, date)
DO UPDATE SET
    total_checks = user_usage_stats.total_checks + EXCLUDED.total_checks,
    total_alerts_triggered = user_usage_stats.total_alerts_triggered + EXCLUDED.total_alerts_triggered,
    total_notifications_sent = user_usage_stats.total_notifications_sent + EXCLUDED.total_notifications_sent,
    api_calls = user_usage_stats.api_calls + EXCLUDED.api_calls,
    data_transfer_bytes = user_usage_stats.data_transfer_bytes + EXCLUDED.data_transfer_bytes
RETURNING user_id, date, total_checks, total_alerts_triggered, total_notifications_sent, api_calls, data_transfer_bytes
`

type UpsertUserUsageStatsParams struct {
	UserID                 uuid.UUID
	Date                   pgtype.Date
	TotalChecks            int32
	TotalAlertsTriggered   int32
	TotalNotificationsSent int32
	ApiCalls               int32
	DataTransferBytes      int64
}

func (q *Queries) UpsertUserUsageStats(ctx context.Context, arg UpsertUserUsageStatsParams) (UserUsageStat, error) {
	row := q.db.QueryRow(ctx, upsertUserUsageStats,
		arg.UserID,
		arg.Date,
		arg.TotalChecks,
		arg.TotalAlertsTriggered,
		arg.TotalNotificationsSent,
		arg.ApiCalls,
		arg.DataTransferBytes,
	)
	var i UserUsageStat
	err := row.Scan(
		&i.UserID,
		&i.Date,
		&i.TotalChecks,
		&i.TotalAlertsTriggered,
		&i.TotalNotificationsSent,
		&i.ApiCalls,
		&i.DataTransferBytes,
	)
	return i, err
}
