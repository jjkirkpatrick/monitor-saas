// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: monitors.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createMonitor = `-- name: CreateMonitor :one
INSERT INTO monitors (
    user_id,
    name,
    type,
    target,
    interval,
    timeout,
    status,
    locations,
    expected_status_codes,
    follow_redirects,
    verify_ssl,
    port,
    dns_record_type,
    expected_response
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, user_id, name, type, target, interval, timeout, status, locations, expected_status_codes, follow_redirects, verify_ssl, port, dns_record_type, expected_response, created_at, updated_at
`

type CreateMonitorParams struct {
	UserID              uuid.UUID
	Name                string
	Type                MonitorType
	Target              string
	Interval            int32
	Timeout             int32
	Status              MonitorStatus
	Locations           []string
	ExpectedStatusCodes []int32
	FollowRedirects     pgtype.Bool
	VerifySsl           pgtype.Bool
	Port                pgtype.Int4
	DnsRecordType       pgtype.Text
	ExpectedResponse    pgtype.Text
}

func (q *Queries) CreateMonitor(ctx context.Context, arg CreateMonitorParams) (Monitor, error) {
	row := q.db.QueryRow(ctx, createMonitor,
		arg.UserID,
		arg.Name,
		arg.Type,
		arg.Target,
		arg.Interval,
		arg.Timeout,
		arg.Status,
		arg.Locations,
		arg.ExpectedStatusCodes,
		arg.FollowRedirects,
		arg.VerifySsl,
		arg.Port,
		arg.DnsRecordType,
		arg.ExpectedResponse,
	)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Type,
		&i.Target,
		&i.Interval,
		&i.Timeout,
		&i.Status,
		&i.Locations,
		&i.ExpectedStatusCodes,
		&i.FollowRedirects,
		&i.VerifySsl,
		&i.Port,
		&i.DnsRecordType,
		&i.ExpectedResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMonitor = `-- name: DeleteMonitor :exec
DELETE FROM monitors
WHERE id = $1 AND user_id = $2
`

type DeleteMonitorParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteMonitor(ctx context.Context, arg DeleteMonitorParams) error {
	_, err := q.db.Exec(ctx, deleteMonitor, arg.ID, arg.UserID)
	return err
}

const getMonitor = `-- name: GetMonitor :one
SELECT id, user_id, name, type, target, interval, timeout, status, locations, expected_status_codes, follow_redirects, verify_ssl, port, dns_record_type, expected_response, created_at, updated_at FROM monitors
WHERE id = $1 AND user_id = $2
`

type GetMonitorParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) GetMonitor(ctx context.Context, arg GetMonitorParams) (Monitor, error) {
	row := q.db.QueryRow(ctx, getMonitor, arg.ID, arg.UserID)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Type,
		&i.Target,
		&i.Interval,
		&i.Timeout,
		&i.Status,
		&i.Locations,
		&i.ExpectedStatusCodes,
		&i.FollowRedirects,
		&i.VerifySsl,
		&i.Port,
		&i.DnsRecordType,
		&i.ExpectedResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMonitorCount = `-- name: GetMonitorCount :one
SELECT COUNT(*) FROM monitors
WHERE user_id = $1
`

func (q *Queries) GetMonitorCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getMonitorCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMonitorWithStats = `-- name: GetMonitorWithStats :one
WITH stats AS (
    SELECT
        monitor_id,
        COUNT(*) as total_checks,
        COUNT(*) FILTER (WHERE success = true) as successful_checks,
        AVG(latency) as avg_latency,
        MAX(latency) as max_latency,
        MIN(latency) as min_latency
    FROM monitor_results
    WHERE monitor_id = $1
    AND time > NOW() - INTERVAL '24 hours'
    GROUP BY monitor_id
)
SELECT
    m.id, m.user_id, m.name, m.type, m.target, m.interval, m.timeout, m.status, m.locations, m.expected_status_codes, m.follow_redirects, m.verify_ssl, m.port, m.dns_record_type, m.expected_response, m.created_at, m.updated_at,
    COALESCE(s.total_checks, 0) as checks_24h,
    COALESCE(s.successful_checks, 0) as successful_checks_24h,
    COALESCE(s.avg_latency, 0) as avg_latency_24h,
    COALESCE(s.max_latency, 0) as max_latency_24h,
    COALESCE(s.min_latency, 0) as min_latency_24h,
    CASE
        WHEN s.total_checks > 0 THEN (s.successful_checks::float / s.total_checks::float) * 100
        ELSE 0
    END as uptime_24h
FROM monitors m
LEFT JOIN stats s ON m.id = s.monitor_id
WHERE m.id = $1 AND m.user_id = $2
`

type GetMonitorWithStatsParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type GetMonitorWithStatsRow struct {
	ID                  uuid.UUID
	UserID              uuid.UUID
	Name                string
	Type                MonitorType
	Target              string
	Interval            int32
	Timeout             int32
	Status              MonitorStatus
	Locations           []string
	ExpectedStatusCodes []int32
	FollowRedirects     pgtype.Bool
	VerifySsl           pgtype.Bool
	Port                pgtype.Int4
	DnsRecordType       pgtype.Text
	ExpectedResponse    pgtype.Text
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	Checks24h           int64
	SuccessfulChecks24h int64
	AvgLatency24h       float64
	MaxLatency24h       interface{}
	MinLatency24h       interface{}
	Uptime24h           int32
}

func (q *Queries) GetMonitorWithStats(ctx context.Context, arg GetMonitorWithStatsParams) (GetMonitorWithStatsRow, error) {
	row := q.db.QueryRow(ctx, getMonitorWithStats, arg.ID, arg.UserID)
	var i GetMonitorWithStatsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Type,
		&i.Target,
		&i.Interval,
		&i.Timeout,
		&i.Status,
		&i.Locations,
		&i.ExpectedStatusCodes,
		&i.FollowRedirects,
		&i.VerifySsl,
		&i.Port,
		&i.DnsRecordType,
		&i.ExpectedResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Checks24h,
		&i.SuccessfulChecks24h,
		&i.AvgLatency24h,
		&i.MaxLatency24h,
		&i.MinLatency24h,
		&i.Uptime24h,
	)
	return i, err
}

const getMonitorsByLocation = `-- name: GetMonitorsByLocation :many
SELECT id, user_id, name, type, target, interval, timeout, status, locations, expected_status_codes, follow_redirects, verify_ssl, port, dns_record_type, expected_response, created_at, updated_at FROM monitors
WHERE status = 'active'
AND $1 = ANY(locations)
ORDER BY created_at DESC
`

func (q *Queries) GetMonitorsByLocation(ctx context.Context, locations []string) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, getMonitorsByLocation, locations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monitor
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Type,
			&i.Target,
			&i.Interval,
			&i.Timeout,
			&i.Status,
			&i.Locations,
			&i.ExpectedStatusCodes,
			&i.FollowRedirects,
			&i.VerifySsl,
			&i.Port,
			&i.DnsRecordType,
			&i.ExpectedResponse,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitorsNeedingCheck = `-- name: GetMonitorsNeedingCheck :many
WITH last_check AS (
    SELECT monitor_id, MAX(time) as last_check_time
    FROM monitor_results
    GROUP BY monitor_id
)
SELECT m.id, m.user_id, m.name, m.type, m.target, m.interval, m.timeout, m.status, m.locations, m.expected_status_codes, m.follow_redirects, m.verify_ssl, m.port, m.dns_record_type, m.expected_response, m.created_at, m.updated_at
FROM monitors m
LEFT JOIN last_check lc ON m.id = lc.monitor_id
WHERE m.status = 'active'
AND (
    lc.last_check_time IS NULL
    OR lc.last_check_time < NOW() - (m.interval || ' seconds')::interval
)
ORDER BY COALESCE(lc.last_check_time, '1970-01-01'::timestamptz) ASC
`

func (q *Queries) GetMonitorsNeedingCheck(ctx context.Context) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, getMonitorsNeedingCheck)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monitor
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Type,
			&i.Target,
			&i.Interval,
			&i.Timeout,
			&i.Status,
			&i.Locations,
			&i.ExpectedStatusCodes,
			&i.FollowRedirects,
			&i.VerifySsl,
			&i.Port,
			&i.DnsRecordType,
			&i.ExpectedResponse,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveMonitors = `-- name: ListActiveMonitors :many
SELECT id, user_id, name, type, target, interval, timeout, status, locations, expected_status_codes, follow_redirects, verify_ssl, port, dns_record_type, expected_response, created_at, updated_at FROM monitors
WHERE status = 'active'
ORDER BY created_at DESC
`

func (q *Queries) ListActiveMonitors(ctx context.Context) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, listActiveMonitors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monitor
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Type,
			&i.Target,
			&i.Interval,
			&i.Timeout,
			&i.Status,
			&i.Locations,
			&i.ExpectedStatusCodes,
			&i.FollowRedirects,
			&i.VerifySsl,
			&i.Port,
			&i.DnsRecordType,
			&i.ExpectedResponse,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitors = `-- name: ListMonitors :many
SELECT id, user_id, name, type, target, interval, timeout, status, locations, expected_status_codes, follow_redirects, verify_ssl, port, dns_record_type, expected_response, created_at, updated_at FROM monitors
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListMonitors(ctx context.Context, userID uuid.UUID) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, listMonitors, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monitor
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Type,
			&i.Target,
			&i.Interval,
			&i.Timeout,
			&i.Status,
			&i.Locations,
			&i.ExpectedStatusCodes,
			&i.FollowRedirects,
			&i.VerifySsl,
			&i.Port,
			&i.DnsRecordType,
			&i.ExpectedResponse,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitorsByType = `-- name: ListMonitorsByType :many
SELECT id, user_id, name, type, target, interval, timeout, status, locations, expected_status_codes, follow_redirects, verify_ssl, port, dns_record_type, expected_response, created_at, updated_at FROM monitors
WHERE user_id = $1 AND type = $2
ORDER BY created_at DESC
`

type ListMonitorsByTypeParams struct {
	UserID uuid.UUID
	Type   MonitorType
}

func (q *Queries) ListMonitorsByType(ctx context.Context, arg ListMonitorsByTypeParams) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, listMonitorsByType, arg.UserID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monitor
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Type,
			&i.Target,
			&i.Interval,
			&i.Timeout,
			&i.Status,
			&i.Locations,
			&i.ExpectedStatusCodes,
			&i.FollowRedirects,
			&i.VerifySsl,
			&i.Port,
			&i.DnsRecordType,
			&i.ExpectedResponse,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMonitor = `-- name: UpdateMonitor :one
UPDATE monitors
SET
    name = COALESCE($3, name),
    type = COALESCE($4, type),
    target = COALESCE($5, target),
    interval = COALESCE($6, interval),
    timeout = COALESCE($7, timeout),
    status = COALESCE($8, status),
    locations = COALESCE($9, locations),
    expected_status_codes = COALESCE($10, expected_status_codes),
    follow_redirects = COALESCE($11, follow_redirects),
    verify_ssl = COALESCE($12, verify_ssl),
    port = COALESCE($13, port),
    dns_record_type = COALESCE($14, dns_record_type),
    expected_response = COALESCE($15, expected_response)
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, name, type, target, interval, timeout, status, locations, expected_status_codes, follow_redirects, verify_ssl, port, dns_record_type, expected_response, created_at, updated_at
`

type UpdateMonitorParams struct {
	ID                  uuid.UUID
	UserID              uuid.UUID
	Name                string
	Type                MonitorType
	Target              string
	Interval            int32
	Timeout             int32
	Status              MonitorStatus
	Locations           []string
	ExpectedStatusCodes []int32
	FollowRedirects     pgtype.Bool
	VerifySsl           pgtype.Bool
	Port                pgtype.Int4
	DnsRecordType       pgtype.Text
	ExpectedResponse    pgtype.Text
}

func (q *Queries) UpdateMonitor(ctx context.Context, arg UpdateMonitorParams) (Monitor, error) {
	row := q.db.QueryRow(ctx, updateMonitor,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Type,
		arg.Target,
		arg.Interval,
		arg.Timeout,
		arg.Status,
		arg.Locations,
		arg.ExpectedStatusCodes,
		arg.FollowRedirects,
		arg.VerifySsl,
		arg.Port,
		arg.DnsRecordType,
		arg.ExpectedResponse,
	)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Type,
		&i.Target,
		&i.Interval,
		&i.Timeout,
		&i.Status,
		&i.Locations,
		&i.ExpectedStatusCodes,
		&i.FollowRedirects,
		&i.VerifySsl,
		&i.Port,
		&i.DnsRecordType,
		&i.ExpectedResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMonitorStatus = `-- name: UpdateMonitorStatus :one
UPDATE monitors
SET status = $3
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, name, type, target, interval, timeout, status, locations, expected_status_codes, follow_redirects, verify_ssl, port, dns_record_type, expected_response, created_at, updated_at
`

type UpdateMonitorStatusParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Status MonitorStatus
}

func (q *Queries) UpdateMonitorStatus(ctx context.Context, arg UpdateMonitorStatusParams) (Monitor, error) {
	row := q.db.QueryRow(ctx, updateMonitorStatus, arg.ID, arg.UserID, arg.Status)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Type,
		&i.Target,
		&i.Interval,
		&i.Timeout,
		&i.Status,
		&i.Locations,
		&i.ExpectedStatusCodes,
		&i.FollowRedirects,
		&i.VerifySsl,
		&i.Port,
		&i.DnsRecordType,
		&i.ExpectedResponse,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
