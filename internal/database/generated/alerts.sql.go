// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: alerts.sql

package sqlc

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acknowledgeAlert = `-- name: AcknowledgeAlert :one
UPDATE alert_history
SET
    status = 'acknowledged',
    acknowledged_at = NOW(),
    acknowledged_by = $3
WHERE id = $1 AND monitor_id = $2
RETURNING id, config_id, monitor_id, status, triggered_at, acknowledged_at, resolved_at, acknowledged_by, details, notification_sent
`

type AcknowledgeAlertParams struct {
	ID             uuid.UUID
	MonitorID      uuid.UUID
	AcknowledgedBy pgtype.UUID
}

func (q *Queries) AcknowledgeAlert(ctx context.Context, arg AcknowledgeAlertParams) (AlertHistory, error) {
	row := q.db.QueryRow(ctx, acknowledgeAlert, arg.ID, arg.MonitorID, arg.AcknowledgedBy)
	var i AlertHistory
	err := row.Scan(
		&i.ID,
		&i.ConfigID,
		&i.MonitorID,
		&i.Status,
		&i.TriggeredAt,
		&i.AcknowledgedAt,
		&i.ResolvedAt,
		&i.AcknowledgedBy,
		&i.Details,
		&i.NotificationSent,
	)
	return i, err
}

const createAlertConfig = `-- name: CreateAlertConfig :one
INSERT INTO alert_configs (
    monitor_id,
    name,
    condition,
    threshold,
    severity,
    enabled,
    consecutive_count,
    cooldown_minutes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, monitor_id, name, condition, threshold, severity, enabled, consecutive_count, cooldown_minutes, created_at, updated_at
`

type CreateAlertConfigParams struct {
	MonitorID        uuid.UUID
	Name             string
	Condition        AlertCondition
	Threshold        json.RawMessage
	Severity         AlertSeverity
	Enabled          bool
	ConsecutiveCount int32
	CooldownMinutes  int32
}

func (q *Queries) CreateAlertConfig(ctx context.Context, arg CreateAlertConfigParams) (AlertConfig, error) {
	row := q.db.QueryRow(ctx, createAlertConfig,
		arg.MonitorID,
		arg.Name,
		arg.Condition,
		arg.Threshold,
		arg.Severity,
		arg.Enabled,
		arg.ConsecutiveCount,
		arg.CooldownMinutes,
	)
	var i AlertConfig
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Name,
		&i.Condition,
		&i.Threshold,
		&i.Severity,
		&i.Enabled,
		&i.ConsecutiveCount,
		&i.CooldownMinutes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAlertHistory = `-- name: CreateAlertHistory :one
INSERT INTO alert_history (
    config_id,
    monitor_id,
    status,
    details
) VALUES (
    $1, $2, $3, $4
) RETURNING id, config_id, monitor_id, status, triggered_at, acknowledged_at, resolved_at, acknowledged_by, details, notification_sent
`

type CreateAlertHistoryParams struct {
	ConfigID  uuid.UUID
	MonitorID uuid.UUID
	Status    AlertStatus
	Details   json.RawMessage
}

func (q *Queries) CreateAlertHistory(ctx context.Context, arg CreateAlertHistoryParams) (AlertHistory, error) {
	row := q.db.QueryRow(ctx, createAlertHistory,
		arg.ConfigID,
		arg.MonitorID,
		arg.Status,
		arg.Details,
	)
	var i AlertHistory
	err := row.Scan(
		&i.ID,
		&i.ConfigID,
		&i.MonitorID,
		&i.Status,
		&i.TriggeredAt,
		&i.AcknowledgedAt,
		&i.ResolvedAt,
		&i.AcknowledgedBy,
		&i.Details,
		&i.NotificationSent,
	)
	return i, err
}

const deleteAlertConfig = `-- name: DeleteAlertConfig :exec
DELETE FROM alert_configs ac
USING monitors m
WHERE ac.id = $1 AND ac.monitor_id = m.id AND m.user_id = $2
`

type DeleteAlertConfigParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteAlertConfig(ctx context.Context, arg DeleteAlertConfigParams) error {
	_, err := q.db.Exec(ctx, deleteAlertConfig, arg.ID, arg.UserID)
	return err
}

const deleteNotificationPreferences = `-- name: DeleteNotificationPreferences :exec
DELETE FROM notification_preferences
WHERE user_id = $1 AND monitor_id = $2
`

type DeleteNotificationPreferencesParams struct {
	UserID    uuid.UUID
	MonitorID uuid.UUID
}

func (q *Queries) DeleteNotificationPreferences(ctx context.Context, arg DeleteNotificationPreferencesParams) error {
	_, err := q.db.Exec(ctx, deleteNotificationPreferences, arg.UserID, arg.MonitorID)
	return err
}

const getActiveAlerts = `-- name: GetActiveAlerts :many
SELECT ah.id, ah.config_id, ah.monitor_id, ah.status, ah.triggered_at, ah.acknowledged_at, ah.resolved_at, ah.acknowledged_by, ah.details, ah.notification_sent
FROM alert_history ah
JOIN monitors m ON ah.monitor_id = m.id
WHERE m.user_id = $1
AND ah.status = 'triggered'
ORDER BY ah.triggered_at DESC
`

func (q *Queries) GetActiveAlerts(ctx context.Context, userID uuid.UUID) ([]AlertHistory, error) {
	rows, err := q.db.Query(ctx, getActiveAlerts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlertHistory
	for rows.Next() {
		var i AlertHistory
		if err := rows.Scan(
			&i.ID,
			&i.ConfigID,
			&i.MonitorID,
			&i.Status,
			&i.TriggeredAt,
			&i.AcknowledgedAt,
			&i.ResolvedAt,
			&i.AcknowledgedBy,
			&i.Details,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlertConfig = `-- name: GetAlertConfig :one
SELECT ac.id, ac.monitor_id, ac.name, ac.condition, ac.threshold, ac.severity, ac.enabled, ac.consecutive_count, ac.cooldown_minutes, ac.created_at, ac.updated_at, m.user_id
FROM alert_configs ac
JOIN monitors m ON ac.monitor_id = m.id
WHERE ac.id = $1 AND m.user_id = $2
`

type GetAlertConfigParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type GetAlertConfigRow struct {
	ID               uuid.UUID
	MonitorID        uuid.UUID
	Name             string
	Condition        AlertCondition
	Threshold        json.RawMessage
	Severity         AlertSeverity
	Enabled          bool
	ConsecutiveCount int32
	CooldownMinutes  int32
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	UserID           uuid.UUID
}

func (q *Queries) GetAlertConfig(ctx context.Context, arg GetAlertConfigParams) (GetAlertConfigRow, error) {
	row := q.db.QueryRow(ctx, getAlertConfig, arg.ID, arg.UserID)
	var i GetAlertConfigRow
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Name,
		&i.Condition,
		&i.Threshold,
		&i.Severity,
		&i.Enabled,
		&i.ConsecutiveCount,
		&i.CooldownMinutes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const getAlertHistory = `-- name: GetAlertHistory :one
SELECT ah.id, ah.config_id, ah.monitor_id, ah.status, ah.triggered_at, ah.acknowledged_at, ah.resolved_at, ah.acknowledged_by, ah.details, ah.notification_sent, m.user_id
FROM alert_history ah
JOIN monitors m ON ah.monitor_id = m.id
WHERE ah.id = $1 AND m.user_id = $2
`

type GetAlertHistoryParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type GetAlertHistoryRow struct {
	ID               uuid.UUID
	ConfigID         uuid.UUID
	MonitorID        uuid.UUID
	Status           AlertStatus
	TriggeredAt      pgtype.Timestamptz
	AcknowledgedAt   pgtype.Timestamptz
	ResolvedAt       pgtype.Timestamptz
	AcknowledgedBy   pgtype.UUID
	Details          json.RawMessage
	NotificationSent bool
	UserID           uuid.UUID
}

func (q *Queries) GetAlertHistory(ctx context.Context, arg GetAlertHistoryParams) (GetAlertHistoryRow, error) {
	row := q.db.QueryRow(ctx, getAlertHistory, arg.ID, arg.UserID)
	var i GetAlertHistoryRow
	err := row.Scan(
		&i.ID,
		&i.ConfigID,
		&i.MonitorID,
		&i.Status,
		&i.TriggeredAt,
		&i.AcknowledgedAt,
		&i.ResolvedAt,
		&i.AcknowledgedBy,
		&i.Details,
		&i.NotificationSent,
		&i.UserID,
	)
	return i, err
}

const getAlertStats = `-- name: GetAlertStats :one
SELECT
    COUNT(*) as total_alerts,
    COUNT(*) FILTER (WHERE status = 'triggered') as active_alerts,
    COUNT(*) FILTER (WHERE status = 'acknowledged') as acknowledged_alerts,
    COUNT(*) FILTER (WHERE status = 'resolved') as resolved_alerts,
    COUNT(*) FILTER (WHERE triggered_at > NOW() - INTERVAL '24 hours') as alerts_24h
FROM alert_history ah
JOIN monitors m ON ah.monitor_id = m.id
WHERE m.user_id = $1
`

type GetAlertStatsRow struct {
	TotalAlerts        int64
	ActiveAlerts       int64
	AcknowledgedAlerts int64
	ResolvedAlerts     int64
	Alerts24h          int64
}

func (q *Queries) GetAlertStats(ctx context.Context, userID uuid.UUID) (GetAlertStatsRow, error) {
	row := q.db.QueryRow(ctx, getAlertStats, userID)
	var i GetAlertStatsRow
	err := row.Scan(
		&i.TotalAlerts,
		&i.ActiveAlerts,
		&i.AcknowledgedAlerts,
		&i.ResolvedAlerts,
		&i.Alerts24h,
	)
	return i, err
}

const getNotificationPreferences = `-- name: GetNotificationPreferences :one
SELECT user_id, monitor_id, email, sms, webhook_url, slack_webhook_url, telegram_chat_id, severity_filter, quiet_hours_start, quiet_hours_end, created_at, updated_at
FROM notification_preferences
WHERE user_id = $1 AND (monitor_id = $2 OR monitor_id IS NULL)
ORDER BY monitor_id NULLS LAST
LIMIT 1
`

type GetNotificationPreferencesParams struct {
	UserID    uuid.UUID
	MonitorID uuid.UUID
}

func (q *Queries) GetNotificationPreferences(ctx context.Context, arg GetNotificationPreferencesParams) (NotificationPreference, error) {
	row := q.db.QueryRow(ctx, getNotificationPreferences, arg.UserID, arg.MonitorID)
	var i NotificationPreference
	err := row.Scan(
		&i.UserID,
		&i.MonitorID,
		&i.Email,
		&i.Sms,
		&i.WebhookUrl,
		&i.SlackWebhookUrl,
		&i.TelegramChatID,
		&i.SeverityFilter,
		&i.QuietHoursStart,
		&i.QuietHoursEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingNotifications = `-- name: GetPendingNotifications :many
SELECT ah.id, ah.config_id, ah.monitor_id, ah.status, ah.triggered_at, ah.acknowledged_at, ah.resolved_at, ah.acknowledged_by, ah.details, ah.notification_sent, np.user_id, np.monitor_id, np.email, np.sms, np.webhook_url, np.slack_webhook_url, np.telegram_chat_id, np.severity_filter, np.quiet_hours_start, np.quiet_hours_end, np.created_at, np.updated_at, m.name as monitor_name
FROM alert_history ah
JOIN monitors m ON ah.monitor_id = m.id
JOIN notification_preferences np ON m.user_id = np.user_id
WHERE ah.notification_sent = false
AND ah.status = 'triggered'
AND (
    np.monitor_id IS NULL
    OR np.monitor_id = ah.monitor_id
)
AND ah.severity = ANY(np.severity_filter)
AND (
    np.quiet_hours_start IS NULL
    OR np.quiet_hours_end IS NULL
    OR NOT (
        CURRENT_TIME >= np.quiet_hours_start
        AND CURRENT_TIME <= np.quiet_hours_end
    )
)
ORDER BY ah.triggered_at ASC
`

type GetPendingNotificationsRow struct {
	ID               uuid.UUID
	ConfigID         uuid.UUID
	MonitorID        uuid.UUID
	Status           AlertStatus
	TriggeredAt      pgtype.Timestamptz
	AcknowledgedAt   pgtype.Timestamptz
	ResolvedAt       pgtype.Timestamptz
	AcknowledgedBy   pgtype.UUID
	Details          json.RawMessage
	NotificationSent bool
	UserID           uuid.UUID
	MonitorID_2      uuid.UUID
	Email            bool
	Sms              bool
	WebhookUrl       pgtype.Text
	SlackWebhookUrl  pgtype.Text
	TelegramChatID   pgtype.Text
	SeverityFilter   []AlertSeverity
	QuietHoursStart  pgtype.Time
	QuietHoursEnd    pgtype.Time
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	MonitorName      string
}

func (q *Queries) GetPendingNotifications(ctx context.Context) ([]GetPendingNotificationsRow, error) {
	rows, err := q.db.Query(ctx, getPendingNotifications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingNotificationsRow
	for rows.Next() {
		var i GetPendingNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.ConfigID,
			&i.MonitorID,
			&i.Status,
			&i.TriggeredAt,
			&i.AcknowledgedAt,
			&i.ResolvedAt,
			&i.AcknowledgedBy,
			&i.Details,
			&i.NotificationSent,
			&i.UserID,
			&i.MonitorID_2,
			&i.Email,
			&i.Sms,
			&i.WebhookUrl,
			&i.SlackWebhookUrl,
			&i.TelegramChatID,
			&i.SeverityFilter,
			&i.QuietHoursStart,
			&i.QuietHoursEnd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MonitorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertConfigs = `-- name: ListAlertConfigs :many
SELECT ac.id, ac.monitor_id, ac.name, ac.condition, ac.threshold, ac.severity, ac.enabled, ac.consecutive_count, ac.cooldown_minutes, ac.created_at, ac.updated_at
FROM alert_configs ac
JOIN monitors m ON ac.monitor_id = m.id
WHERE m.user_id = $1
ORDER BY ac.created_at DESC
`

func (q *Queries) ListAlertConfigs(ctx context.Context, userID uuid.UUID) ([]AlertConfig, error) {
	rows, err := q.db.Query(ctx, listAlertConfigs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlertConfig
	for rows.Next() {
		var i AlertConfig
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.Name,
			&i.Condition,
			&i.Threshold,
			&i.Severity,
			&i.Enabled,
			&i.ConsecutiveCount,
			&i.CooldownMinutes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertConfigsByMonitor = `-- name: ListAlertConfigsByMonitor :many
SELECT id, monitor_id, name, condition, threshold, severity, enabled, consecutive_count, cooldown_minutes, created_at, updated_at
FROM alert_configs
WHERE monitor_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAlertConfigsByMonitor(ctx context.Context, monitorID uuid.UUID) ([]AlertConfig, error) {
	rows, err := q.db.Query(ctx, listAlertConfigsByMonitor, monitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlertConfig
	for rows.Next() {
		var i AlertConfig
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.Name,
			&i.Condition,
			&i.Threshold,
			&i.Severity,
			&i.Enabled,
			&i.ConsecutiveCount,
			&i.CooldownMinutes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertHistory = `-- name: ListAlertHistory :many
SELECT ah.id, ah.config_id, ah.monitor_id, ah.status, ah.triggered_at, ah.acknowledged_at, ah.resolved_at, ah.acknowledged_by, ah.details, ah.notification_sent
FROM alert_history ah
JOIN monitors m ON ah.monitor_id = m.id
WHERE m.user_id = $1
ORDER BY ah.triggered_at DESC
LIMIT $2
`

type ListAlertHistoryParams struct {
	UserID uuid.UUID
	Limit  int32
}

func (q *Queries) ListAlertHistory(ctx context.Context, arg ListAlertHistoryParams) ([]AlertHistory, error) {
	rows, err := q.db.Query(ctx, listAlertHistory, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlertHistory
	for rows.Next() {
		var i AlertHistory
		if err := rows.Scan(
			&i.ID,
			&i.ConfigID,
			&i.MonitorID,
			&i.Status,
			&i.TriggeredAt,
			&i.AcknowledgedAt,
			&i.ResolvedAt,
			&i.AcknowledgedBy,
			&i.Details,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertHistoryByMonitor = `-- name: ListAlertHistoryByMonitor :many
SELECT id, config_id, monitor_id, status, triggered_at, acknowledged_at, resolved_at, acknowledged_by, details, notification_sent
FROM alert_history
WHERE monitor_id = $1
ORDER BY triggered_at DESC
LIMIT $2
`

type ListAlertHistoryByMonitorParams struct {
	MonitorID uuid.UUID
	Limit     int32
}

func (q *Queries) ListAlertHistoryByMonitor(ctx context.Context, arg ListAlertHistoryByMonitorParams) ([]AlertHistory, error) {
	rows, err := q.db.Query(ctx, listAlertHistoryByMonitor, arg.MonitorID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlertHistory
	for rows.Next() {
		var i AlertHistory
		if err := rows.Scan(
			&i.ID,
			&i.ConfigID,
			&i.MonitorID,
			&i.Status,
			&i.TriggeredAt,
			&i.AcknowledgedAt,
			&i.ResolvedAt,
			&i.AcknowledgedBy,
			&i.Details,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotificationPreferences = `-- name: ListNotificationPreferences :many
SELECT user_id, monitor_id, email, sms, webhook_url, slack_webhook_url, telegram_chat_id, severity_filter, quiet_hours_start, quiet_hours_end, created_at, updated_at
FROM notification_preferences
WHERE user_id = $1
ORDER BY monitor_id NULLS LAST
`

func (q *Queries) ListNotificationPreferences(ctx context.Context, userID uuid.UUID) ([]NotificationPreference, error) {
	rows, err := q.db.Query(ctx, listNotificationPreferences, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotificationPreference
	for rows.Next() {
		var i NotificationPreference
		if err := rows.Scan(
			&i.UserID,
			&i.MonitorID,
			&i.Email,
			&i.Sms,
			&i.WebhookUrl,
			&i.SlackWebhookUrl,
			&i.TelegramChatID,
			&i.SeverityFilter,
			&i.QuietHoursStart,
			&i.QuietHoursEnd,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNotificationSent = `-- name: MarkNotificationSent :exec
UPDATE alert_history
SET notification_sent = true
WHERE id = $1
`

func (q *Queries) MarkNotificationSent(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markNotificationSent, id)
	return err
}

const resolveAlert = `-- name: ResolveAlert :one
UPDATE alert_history
SET
    status = 'resolved',
    resolved_at = NOW()
WHERE id = $1 AND monitor_id = $2
RETURNING id, config_id, monitor_id, status, triggered_at, acknowledged_at, resolved_at, acknowledged_by, details, notification_sent
`

type ResolveAlertParams struct {
	ID        uuid.UUID
	MonitorID uuid.UUID
}

func (q *Queries) ResolveAlert(ctx context.Context, arg ResolveAlertParams) (AlertHistory, error) {
	row := q.db.QueryRow(ctx, resolveAlert, arg.ID, arg.MonitorID)
	var i AlertHistory
	err := row.Scan(
		&i.ID,
		&i.ConfigID,
		&i.MonitorID,
		&i.Status,
		&i.TriggeredAt,
		&i.AcknowledgedAt,
		&i.ResolvedAt,
		&i.AcknowledgedBy,
		&i.Details,
		&i.NotificationSent,
	)
	return i, err
}

const updateAlertConfig = `-- name: UpdateAlertConfig :one
UPDATE alert_configs
SET
    name = COALESCE($3, name),
    condition = COALESCE($4, condition),
    threshold = COALESCE($4, threshold),
    severity = COALESCE($5, severity),
    enabled = COALESCE($6, enabled),
    consecutive_count = COALESCE($7, consecutive_count),
    cooldown_minutes = COALESCE($8, cooldown_minutes)
WHERE id = $1 AND monitor_id = $2
RETURNING id, monitor_id, name, condition, threshold, severity, enabled, consecutive_count, cooldown_minutes, created_at, updated_at
`

type UpdateAlertConfigParams struct {
	ID               uuid.UUID
	MonitorID        uuid.UUID
	Name             string
	Condition        AlertCondition
	Severity         AlertSeverity
	Enabled          bool
	ConsecutiveCount int32
	CooldownMinutes  int32
}

func (q *Queries) UpdateAlertConfig(ctx context.Context, arg UpdateAlertConfigParams) (AlertConfig, error) {
	row := q.db.QueryRow(ctx, updateAlertConfig,
		arg.ID,
		arg.MonitorID,
		arg.Name,
		arg.Condition,
		arg.Severity,
		arg.Enabled,
		arg.ConsecutiveCount,
		arg.CooldownMinutes,
	)
	var i AlertConfig
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Name,
		&i.Condition,
		&i.Threshold,
		&i.Severity,
		&i.Enabled,
		&i.ConsecutiveCount,
		&i.CooldownMinutes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertNotificationPreferences = `-- name: UpsertNotificationPreferences :one
INSERT INTO notification_preferences (
    user_id,
    monitor_id,
    email,
    sms,
    webhook_url,
    slack_webhook_url,
    telegram_chat_id,
    severity_filter,
    quiet_hours_start,
    quiet_hours_end
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
ON CONFLICT (user_id, COALESCE(monitor_id, '00000000-0000-0000-0000-000000000000'::UUID))
DO UPDATE SET
    email = EXCLUDED.email,
    sms = EXCLUDED.sms,
    webhook_url = EXCLUDED.webhook_url,
    slack_webhook_url = EXCLUDED.slack_webhook_url,
    telegram_chat_id = EXCLUDED.telegram_chat_id,
    severity_filter = EXCLUDED.severity_filter,
    quiet_hours_start = EXCLUDED.quiet_hours_start,
    quiet_hours_end = EXCLUDED.quiet_hours_end,
    updated_at = NOW()
RETURNING user_id, monitor_id, email, sms, webhook_url, slack_webhook_url, telegram_chat_id, severity_filter, quiet_hours_start, quiet_hours_end, created_at, updated_at
`

type UpsertNotificationPreferencesParams struct {
	UserID          uuid.UUID
	MonitorID       uuid.UUID
	Email           bool
	Sms             bool
	WebhookUrl      pgtype.Text
	SlackWebhookUrl pgtype.Text
	TelegramChatID  pgtype.Text
	SeverityFilter  []AlertSeverity
	QuietHoursStart pgtype.Time
	QuietHoursEnd   pgtype.Time
}

func (q *Queries) UpsertNotificationPreferences(ctx context.Context, arg UpsertNotificationPreferencesParams) (NotificationPreference, error) {
	row := q.db.QueryRow(ctx, upsertNotificationPreferences,
		arg.UserID,
		arg.MonitorID,
		arg.Email,
		arg.Sms,
		arg.WebhookUrl,
		arg.SlackWebhookUrl,
		arg.TelegramChatID,
		arg.SeverityFilter,
		arg.QuietHoursStart,
		arg.QuietHoursEnd,
	)
	var i NotificationPreference
	err := row.Scan(
		&i.UserID,
		&i.MonitorID,
		&i.Email,
		&i.Sms,
		&i.WebhookUrl,
		&i.SlackWebhookUrl,
		&i.TelegramChatID,
		&i.SeverityFilter,
		&i.QuietHoursStart,
		&i.QuietHoursEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
